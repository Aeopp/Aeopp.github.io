---
layout: post
title: 메모리 장벽 과 메모리 오더
subtitle: Memory_order Memory_visibility 
cover-img: /assets/img/path.jpg
share-img: /assets/img/path.jpg
tags: [I Understand concept, System]
---

# Memory Visibility (메모리 가시성)
## C++ 11 이후부터 표준에 memory_order 이라는 개념이 추가되었다고 한다.
 * 메모리 가시성에 대해 간단히 말하자면 어떠한 Thread 에서 변경한 메모리의 값이 다른 Thread 에서도 제대로 (관찰)읽어지느냐에 대한 것이다

 이 메모리 가시성은 다중코어 CPU에서 중요한 이슈이다. 싱글코어 CPU 에서는 
 쓰레드가 컨텍스트 스위칭 될때에 레지스터와 Program Counter(PC), 스택프레 임 등등 하드웨어 정보가 교체되겠지만 캐쉬 메모리는 교체될 필요가 없을 것이다. (교체되는 쓰레드가 같은 프로세스내에 있다면)

 그렇다면 프로그래머가 신경써야할 주제는 쓰레드가 메모리에 값을 변경할때에 레지스터의 값을 메모리에 반영하는 그 순간으로 좁혀진다.
 해당 연산을 atomic 하게 수행하게 하거나 공유리소스를 건드는 코드블록에 임계영역을 걸어버리면 문제는 간단히 해결된다.
 다중코어 CPU 에서는 쓰레드간 독립적인 캐쉬메모리가 존재하기 때문에 해당 이슈에 대해서 조금 더 생각해봐야 한다 
 (정확히는 여러개의 코어들의 캐쉬메모리가 독립적인것이다)

 각각의 코어(CPU) 들은 메인 메모리는 공유하지만 각각의 레지스터와 캐쉬를 가지고 있다 (이 레지스터 정보가 쓰레드마다 다르기 때문에 싱글코어에서도 Race condition 문제가 발생하는 것이라는 것을 짚고 넘어가고 싶다.)
 그리고 컴파일러의 최적화 덕분에 CPU는 메인메모리가 아닌 레지스터와 캐쉬를
 최대한 사용하도록 동작된다

 






