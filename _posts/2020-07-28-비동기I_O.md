---
layout: post
title: 비동기I/O 와 동기 I/O 에 대해서
subtitle: Concept I understand
gh-repo: aeopp/os_system_programming
gh-badge: [star, fork, follow]
tags: [Asynchronous_I/O]
comments: true
---

## 동기 I/O 비동기 I/O 에서 무엇이 "동기화" 되었고 무엇이 "비동기화" 되었길래 이런 용어까지 생겨난 것일까??
일단 동기I/O 는 I/O 연산을 실행하는 함수 호출 이후에 함수의 반환시점이 I/O 연산의 종료와 일치한다.
반면에 비동기 I/O 는 I/O 연산을 실행하는 함수 호출 이후 함수의 반환시점이 I/O 연산의 종료와 일치하지 않는다.

그렇다 ! 동기 I/O 는 I/O연산을 담당하는 함수의 반환시점과 I/O 연산의 종료가 "동기화" 되었다는 것이고
        비동기 I/O 는 그렇지 않은 것이다.

여기서 동기I/O 연산을 할시에 사용하는 함수는 당연히 함수의 반환시점이 곧 Procedure 의 종료를 의미하는 "블로킹 함수"인것이고
      비동기I/O 연산을 할시에 사용하는 함수는 "함수의 호출 직후에 함수가 반환되며 Procedure 의 종료는 다른 방법으로 Caller가 전달받아야 하는 "넌 블로킹 함수"인것이다

비동기 I/O 을 사용할때에는 **"중첩(Overlapped)"** 과 **"완료루틴"** 이라고 부르는 기법들이 존재하는데
**"완료루틴"** 은 비동기 함수를 호출한 이후에 해당 작업을 신경쓰지않고 프로세스의 흐름이 이어가다가 
비동기 함수의 작업이 종료됐을시에 등록해놓았던 CALLBACK 함수가 호출 되는 방식으로 구현한다.
"중첩(I/O)"는 완료루틴과 마찬가지로 비동기 함수를 호출하지만 CALLBACK 함수가 호출되는 식의 장치가 없기 때문에
중간에 I/O 연산이 완료되었는지 확인을 하는 별도의 과정이 필요하다.

여기서 완료루틴을 운영체제가 구현한 방법으로 **"APC Queue"** 가 등장하는데
APC Queue 란 쓰레드가 알림가능한상태일시에 호출해주는 함수와 매개변수들의 **"Queue"** 이다
쓰레드에 독립적이며 (다시말하면 쓰레드별로 하나씩 가지고 있다) **"알림가능한상태!!!!" 일때만 호출해주므로 주의.**


